#include <iostream>
#include <vector>
#include <algorithm>
#include <functional>   // для работы с функциональными объектами
#include <string>
#include <numeric>      //  для численных алгоритмов

// Обычная функция для использования в примерах
int multiply(int x, int y) {
    return x * y; // Умножение двух чисел
}

int main() {
    std::cout << "=== Простые лямбда-выражения ===" << std::endl;
    
    // Простая лямбда-функция без параметров
    auto hello = []() { 
        std::cout << "Привет из лямбда-функции!" << std::endl; 
    }; // Объявление лямбда-функции
    
    hello(); // Вызов лямбда-функции
    
    // Лямбда-функция с параметрами
    auto add = [](int a, int b) {
        return a + b; // Сложение двух чисел
    }; // Объявление лямбда-функции с параметрами
    
    std::cout << "5 + 3 = " << add(5, 3) << std::endl; // Вызов лямбда-функции
    
    // Лямбда с явным указанием типа возвращаемого значения
    auto subtract = [](int a, int b) -> double {
        return static_cast<double>(a - b); // Вычитание с явным приведением к double
    }; // Объявление лямбда-функции с указанием типа возвращаемого значения
    
    std::cout << "5 - 3 = " << subtract(5, 3) << std::endl; // Вызов лямбда-функции
    
    std::cout << "\n=== Захват переменных в лямбда-выражениях ===" << std::endl;
    
    int x = 10; // Переменная для захвата
    int y = 5;  // Еще одна переменная для захвата
    
    // Захват по значению (копия переменной)
    auto val_capture = [x]() {
        return x * 2; // Использование захваченной переменной
    }; // Объявление лямбда-функции с захватом по значению
    
    std::cout << "Захват по значению: " << val_capture() << std::endl; // Вызов лямбда-функции
    
    // Захват по ссылке (ссылка на переменную)
    auto ref_capture = [&x]() {
        x += 5; // Изменение захваченной переменной
        return x; // Возврат измененного значения
    }; // Объявление лямбда-функции с захватом по ссылке
    
    std::cout << "До вызова лямбды с захватом по ссылке: x = " << x << std::endl; // Вывод значения переменной
    std::cout << "Результат лямбды: " << ref_capture() << std::endl; // Вызов лямбда-функции
    std::cout << "После вызова лямбды: x = " << x << std::endl; // Вывод измененного значения переменной
    
    // Захват нескольких переменных
    auto multi_capture = [x, y]() {
        return x * y; // Использование двух захваченных переменных
    }; // Объявление лямбда-функции с захватом нескольких переменных
    
    std::cout << "Захват нескольких переменных: " << multi_capture() << std::endl; // Вызов лямбда-функции
    
    // Захват всех переменных из области видимости по значению
    auto capture_all_by_value = [=]() {
        return x + y; // Использование всех захваченных переменных
    }; // Объявление лямбда-функции с захватом всех переменных по значению
    
    std::cout << "Захват всех по значению: " << capture_all_by_value() << std::endl; // Вызов лямбда-функции
    
    // Захват всех переменных из области видимости по ссылке
    auto capture_all_by_reference = [&]() {
        x += 2; // Изменение переменной x
        y *= 2; // Изменение переменной y
        return x + y; // Возврат суммы измененных значений
    }; // Объявление лямбда-функции с захватом всех переменных по ссылке
    
    std::cout << "До вызова лямбды с захватом всех по ссылке: x = " << x << ", y = " << y << std::endl; // Вывод значений переменных
    std::cout << "Результат лямбды: " << capture_all_by_reference() << std::endl; // Вызов лямбда-функции
    std::cout << "После вызова лямбды: x = " << x << ", y = " << y << std::endl; // Вывод измененных значений переменных
    
    // Смешанный захват
    auto mixed_capture = [=, &y]() {
        // x не может быть изменен (захват по значению)
        // y может быть изменен (захват по ссылке)
        y += 10; // Изменение переменной y
        return x + y; // Возврат суммы
    }; // Объявление лямбда-функции со смешанным захватом
    
    std::cout << "До вызова лямбды со смешанным захватом: x = " << x << ", y = " << y << std::endl; // Вывод значений переменных
    std::cout << "Результат лямбды: " << mixed_capture() << std::endl; // Вызов лямбда-функции
    std::cout << "После вызова лямбды: x = " << x << ", y = " << y << std::endl; // Вывод значений переменных
    
    std::cout << "\n=== Использование лямбда-выражений с алгоритмами STL ===" << std::endl;
    
    std::vector<int> numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; // Вектор чисел для примеров
    
    // Подсчет элементов, удовлетворяющих условию
    int count_even = std::count_if(numbers.begin(), numbers.end(), 
                                 [](int n) { return n % 2 == 0; }); // Подсчет четных чисел
    
    std::cout << "Количество четных чисел: " << count_even << std::endl; // Вывод результата
    
    // Поиск первого элемента, удовлетворяющего условию
    auto it = std::find_if(numbers.begin(), numbers.end(), 
                          [](int n) { return n > 5; }); // Поиск первого числа, большего 5
    
    if (it != numbers.end()) { // Если найден элемент
        std::cout << "Первое число больше 5: " << *it << std::endl; // Вывод найденного элемента
    }
    
    // Преобразование элементов с помощью transform
    std::vector<int> squared(numbers.size()); // Создание вектора для результатов
    
    std::transform(numbers.begin(), numbers.end(), squared.begin(), 
                 [](int n) { return n * n; }); // Возведение в квадрат каждого элемента
    
    std::cout << "Числа, возведенные в квадрат: ";
    for (int n : squared) { // Для каждого элемента в векторе
        std::cout << n << " "; // Вывод элемента
    }
    std::cout << std::endl;
    
    // Удаление элементов с помощью remove_if
    auto new_end = std::remove_if(numbers.begin(), numbers.end(), 
                                [](int n) { return n % 2 != 0; }); // Удаление нечетных чисел
    
    numbers.erase(new_end, numbers.end()); // Фактическое удаление элементов
    
    std::cout << "Вектор после удаления нечетных чисел: ";
    for (int n : numbers) { // Для каждого элемента в векторе
        std::cout << n << " "; // Вывод элемента
    }
    std::cout << std::endl;
    
    // Восстановление вектора
    numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; // Восстановление начальных значений
    
    // Сортировка с помощью лямбда-выражения
    std::sort(numbers.begin(), numbers.end(), 
            [](int a, int b) { return a > b; }); // Сортировка по убыванию
    
    std::cout << "Вектор после сортировки по убыванию: ";
    for (int n : numbers) { // Для каждого элемента в векторе
        std::cout << n << " "; // Вывод элемента
    }
    std::cout << std::endl;
    
    // Использование лямбда-выражения с алгоритмом накопления
    int sum = std::accumulate(numbers.begin(), numbers.end(), 0, 
                            [](int acc, int n) { return acc + n; }); // Суммирование элементов
    
    std::cout << "Сумма всех элементов: " << sum << std::endl; // Вывод суммы
    
    // Использование лямбда-выражения для фильтрации и преобразования
    std::vector<std::string> names = {"Анна", "Иван", "Петр", "Мария", "Александр"}; // Вектор строк
    
    // Фильтрация имен, начинающихся с 'А'
    std::vector<std::string> a_names; // Вектор для результатов
    
    std::copy_if(names.begin(), names.end(), std::back_inserter(a_names), 
               [](const std::string& name) { return name[0] == 'А'; }); // Копирование имен, начинающихся с 'А'
    
    std::cout << "Имена, начинающиеся с 'А': ";
    for (const auto& name : a_names) { // Для каждого имени
        std::cout << name << " "; // Вывод имени
    }
    std::cout << std::endl;
    
    // Преобразование имен в их длины
    std::vector<size_t> name_lengths; // Вектор для результатов
    
    std::transform(names.begin(), names.end(), std::back_inserter(name_lengths), 
                 [](const std::string& name) { return name.length(); }); // Преобразование имен в их длины
    
    std::cout << "Длины имен: ";
    for (size_t len : name_lengths) { // Для каждой длины
        std::cout << len << " "; // Вывод длины
    }
    std::cout << std::endl;
    
    std::cout << "\n=== Использование std::function и хранение лямбда-выражений ===" << std::endl;
    
    // Хранение лямбда-выражения в std::function
    std::function<int(int, int)> operation; // Объявление функционального объекта
    
    // Присваивание лямбда-выражения
    operation = [](int a, int b) { return a + b; }; // Присваивание операции сложения
    
    std::cout << "Результат операции (сложение): " << operation(10, 5) << std::endl; // Вызов функции
    
    // Изменение операции на умножение
    operation = multiply; // Присваивание обычной функции умножения
    
    std::cout << "Результат операции (умножение): " << operation(10, 5) << std::endl; // Вызов функции
    
    // Вектор функций
    std::vector<std::function<int(int)>> operations; // Вектор функциональных объектов
    
    // Добавление различных операций
    operations.push_back([](int x) { return x * 2; }); // Добавление операции умножения на 2
    operations.push_back([](int x) { return x * x; }); // Добавление операции возведения в квадрат
    operations.push_back([](int x) { return x + 10; }); // Добавление операции добавления 10
    
    // Применение всех операций к числу
    int value = 5; // Исходное значение
    
    std::cout << "Применение цепочки операций к " << value << ":" << std::endl;
    for (const auto& op : operations) { // Для каждой операции
        value = op(value); // Применение операции
        std::cout << "После операции: " << value << std::endl; // Вывод результата
    }
    
    return 0;
}
