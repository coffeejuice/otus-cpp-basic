#include <iostream>
#include <thread>
#include <mutex>
#include <chrono>
#include <vector>
#include <functional>

// Глобальная переменная, как разделяемый между потоками счетчик
int shared_counter = 0;

// Мьютекс для защиты доступа к shared_counter
std::mutex counter_mutex;

// Простая функция для запуска в отдельном потоке
void simple_task() {
    std::cout << "Простая задача выполняется в потоке: " 
              << std::this_thread::get_id() << std::endl; // Вывод идентификатора потока
}

// Функция с параметрами для запуска в отдельном потоке
void parameterized_task(const std::string& message, int repeats) {
    for (int i = 0; i < repeats; i++) { // Цикл повторения
        std::cout << "Сообщение " << i + 1 << "/" << repeats 
                  << " из потока " << std::this_thread::get_id() 
                  << ": " << message << std::endl; // Вывод сообщения
        
        std::this_thread::sleep_for(std::chrono::milliseconds(100)); // Пауза на 100 миллисекунд
    }
}

// Функция, увеличивающая счетчик без синхронизации
void increment_without_mutex(int iterations) {
    for (int i = 0; i < iterations; i++) { // Цикл увеличения счетчика
        shared_counter++; // Увеличение счетчика без синхронизации
        std::this_thread::sleep_for(std::chrono::microseconds(1)); // Небольшая пауза
    }
}

// Функция, увеличивающая счетчик с использованием мьютекса
void increment_with_mutex(int iterations) {
    for (int i = 0; i < iterations; i++) { // Цикл увеличения счетчика
        // Блокировка мьютекса перед доступом к shared_counter
        counter_mutex.lock(); // Блокировка мьютекса
        shared_counter++; // Увеличение счетчика (защищенный доступ)
        counter_mutex.unlock(); // Разблокировка мьютекса
        
        std::this_thread::sleep_for(std::chrono::microseconds(1)); // Небольшая пауза
    }
}

// Функция, использующая RAII-обертку для мьютекса
void increment_with_lock_guard(int iterations) {
    for (int i = 0; i < iterations; i++) { // Цикл увеличения счетчика
        {
            // Автоматическая блокировка и разблокировка мьютекса
            std::lock_guard<std::mutex> guard(counter_mutex); // Создание объекта блокировки
            shared_counter++; // Увеличение счетчика (защищенный доступ)
        } // guard автоматически разблокирует мьютекс при выходе из области видимости
        
        std::this_thread::sleep_for(std::chrono::microseconds(1)); // Небольшая пауза
    }
}

int main() {
    std::cout << "=== Пример работы с потоками ===" << std::endl;
    
    // Запуск простой задачи в отдельном потоке
    std::thread t1(simple_task); // Создание и запуск потока
    
    // Ожидание завершения потока
    t1.join(); // Ожидание завершения потока t1
    
    // Запуск задачи с параметрами в отдельном потоке
    std::thread t2(parameterized_task, "Привет из потока!", 3); // Создание и запуск потока с параметрами
    
    // Выполнение чего-то в основном потоке, пока работает t2
    std::cout << "Основной поток продолжает работу." << std::endl; // Вывод сообщения из основного потока
    
    // Ожидание завершения потока с параметрами
    t2.join(); // Ожидание завершения потока t2
    
    std::cout << "\n=== Проблема гонки данных ===" << std::endl;
    
    // Сброс счетчика
    shared_counter = 0; // Сброс счетчика перед экспериментом
    
    // Запуск двух потоков, которые увеличивают счетчик без синхронизации
    std::thread t3(increment_without_mutex, 1000); // Создание и запуск первого потока
    std::thread t4(increment_without_mutex, 1000); // Создание и запуск второго потока
    
    // Ожидание завершения потоков
    t3.join(); // Ожидание завершения потока t3
    t4.join(); // Ожидание завершения потока t4
    
    // Вывод результата (может быть меньше 2000 из-за гонки данных)
    std::cout << "Значение счетчика после работы без мьютекса: " 
              << shared_counter << " (должно быть 2000)" << std::endl; // Вывод значения счетчика
    
    std::cout << "\n=== Использование мьютексов ===" << std::endl;
    
    // Сброс счетчика
    shared_counter = 0; // Сброс счетчика перед новым экспериментом
    
    // Запуск двух потоков, которые увеличивают счетчик с использованием мьютекса
    std::thread t5(increment_with_mutex, 1000); // Создание и запуск первого потока
    std::thread t6(increment_with_mutex, 1000); // Создание и запуск второго потока
    
    // Ожидание завершения потоков
    t5.join(); // Ожидание завершения потока t5
    t6.join(); // Ожидание завершения потока t6
    
    // Вывод результата (должно быть ровно 2000)
    std::cout << "Значение счетчика после работы с мьютексом: " 
              << shared_counter << " (должно быть 2000)" << std::endl; // Вывод значения счетчика
    
    std::cout << "\n=== Использование RAII-обертки для мьютекса ===" << std::endl;
    
    // Сброс счетчика
    shared_counter = 0; // Сброс счетчика перед новым экспериментом
    
    // Запуск двух потоков, которые увеличивают счетчик с использованием lock_guard
    std::thread t7(increment_with_lock_guard, 1000); // Создание и запуск первого потока
    std::thread t8(increment_with_lock_guard, 1000); // Создание и запуск второго потока
    
    // Ожидание завершения потоков
    t7.join(); // Ожидание завершения потока t7
    t8.join(); // Ожидание завершения потока t8
    
    // Вывод результата (должно быть ровно 2000)
    std::cout << "Значение счетчика после работы с lock_guard: " 
              << shared_counter << " (должно быть 2000)" << std::endl; // Вывод значения счетчика



    std::cout << "\n=== Создание нескольких потоков одновременно ===" << std::endl;
    const int num_threads = 5;        // Количество потоков
    std::vector<std::thread> threads; // Вектор для хранения потоков
    
    // Создание потоков
    for (int i = 0; i < num_threads; i++) { // Цикл создания потоков
        // Лямбда-функция с захватом переменной i по значению
        threads.push_back(std::thread([i]() {
            std::cout << "Поток " << i << " запущен, ID: " 
                      << std::this_thread::get_id() << std::endl; // Вывод сообщения
            // Имитация работы
            std::this_thread::sleep_for(std::chrono::milliseconds(500 + i * 100)); // Пауза
            std::cout << "Поток " << i << " завершен" << std::endl; // Вывод сообщения о завершении
        }));
    }
    
    // Ожидание завершения всех потоков
    for (auto& t : threads) { // Для каждого потока в векторе
        t.join(); // Ожидание завершения потока
    }
    
    std::cout << "Все потоки завершены" << std::endl;
    
    return 0;
}
